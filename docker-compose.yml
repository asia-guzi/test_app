#Ścieżka do rozwiązania:
#Dodanie oddzielnego kroku do Docker Compose
#Możesz stworzyć jednorazowy kontener, który uruchomi Twój skrypt initial_populate.py. Wtedy wygląda to tak:
#Przykład docker-compose.yml:
#
#yaml
#
#
#version: '3.9'
#services:
#  app:
#    build: .
#    ports:
#      - "8000:8080"
#    environment:
#      DATABASE_HOST: db
#      DATABASE_PORT: 3306
#      DATABASE_USER: my_user
#      DATABASE_PASSWORD: my_password
#      DATABASE_NAME: my_database
#    depends_on:
#      - db
#
#  db:
#    image: mysql:8.0
#    restart: always
#    environment:
#      MYSQL_ROOT_PASSWORD: example
#      MYSQL_DATABASE: my_database
#      MYSQL_USER: my_user
#      MYSQL_PASSWORD: my_password
#    volumes:
#      - db_data:/var/lib/mysql
#
#  initial_populate:
#    build:
#      context: .
#    depends_on:
#      - db
#    environment:
#      DATABASE_HOST: db
#      DATABASE_PORT: 3306
#      DATABASE_USER: my_user
#      DATABASE_PASSWORD: my_password
#      DATABASE_NAME: my_database
#    command: >
#      python3 /path/to/initial_populate.py
#Wyjaśnienie, jak to działa:
#Sekcja initial_populate:
#
#Tworzy oddzielny kontener, który uruchamia Twój plik initial_populate.py.
#command: python3 /path/to/initial_populate.py – uruchamia twój skrypt inicjalizacyjny.
#depends_on:
#
#Kontener initial_populate poczeka na uruchomienie kontenera db i wykonanie bazy danych (depends_on sprawi, że baza zostanie uruchomiona jako pierwsza).
#Po wykonaniu skryptu initial_populate.py, kontener initial_populate zakończy swoje zadanie i przestanie działać (bo to jednorazowe zadanie).
#
#Dane pozostają w bazie danych:
#
#Zostały zapisane dzięki zamontowanemu volume (db_data).
#
#
#
#=--------------------------------------------------------------------
#
#Ścieżka do rozwiązania:
#Dodanie oddzielnego kroku do Docker Compose
#Możesz stworzyć jednorazowy kontener, który uruchomi Twój skrypt initial_populate.py. Wtedy wygląda to tak:
#Przykład docker-compose.yml:
#
#yaml
#
#
#version: '3.9'
#services:
#  app:
#    build: .
#    ports:
#      - "8000:8080"
#    environment:
#      DATABASE_HOST: db
#      DATABASE_PORT: 3306
#      DATABASE_USER: my_user
#      DATABASE_PASSWORD: my_password
#      DATABASE_NAME: my_database
#    depends_on:
#      - db
#
#  db:
#    image: mysql:8.0
#    restart: always
#    environment:
#      MYSQL_ROOT_PASSWORD: example
#      MYSQL_DATABASE: my_database
#      MYSQL_USER: my_user
#      MYSQL_PASSWORD: my_password
#    volumes:
#      - db_data:/var/lib/mysql
#
#  initial_populate:
#    build:
#      context: .
#    depends_on:
#      - db
#    environment:
#      DATABASE_HOST: db
#      DATABASE_PORT: 3306
#      DATABASE_USER: my_user
#      DATABASE_PASSWORD: my_password
#      DATABASE_NAME: my_database
#    command: >
#      python3 /path/to/initial_populate.py
#Wyjaśnienie, jak to działa:
#Sekcja initial_populate:
#
#Tworzy oddzielny kontener, który uruchamia Twój plik initial_populate.py.
#command: python3 /path/to/initial_populate.py – uruchamia twój skrypt inicjalizacyjny.
#depends_on:
#
#Kontener initial_populate poczeka na uruchomienie kontenera db i wykonanie bazy danych (depends_on sprawi, że baza zostanie uruchomiona jako pierwsza).
#Po wykonaniu skryptu initial_populate.py, kontener initial_populate zakończy swoje zadanie i przestanie działać (bo to jednorazowe zadanie).
#
#Dane pozostają w bazie danych:
#
#Zostały zapisane dzięki zamontowanemu volume (db_data).